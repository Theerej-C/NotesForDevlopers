## Item 1: Use the static factory method instead of the constructor.
* Normally a class will provide a constructor for the object building but there is a static facatory method to do the same thing. For Example:
```
public static Boolean valueOf(boolean b){
    return b?Boolean.TRUE:Boolean.False;
}
```
* This translates boolean primitive to Boolean object reference.
* There are many advantages to the static factory methods:
    1. Unlike constructors they have names.
    2. Unlike constructor they are not required to create a new object each time they are invoked.
    3. Unlike constructors that can return an object of any subtype of their return type.
    4. The return object class need not to be exist when the class containing the method is written.
    5. Class of returned object can vary from call to call as a function of the input parameter.
* The main limitation of the static factory method is that when we use the static factory only then there can be no subclass creation.
* Then the names of the methods are need to be explicitly mentioned in the documents so that the programmers can use it.
## Use the Builder when faced with many constructor params
* When there are many optional parameters in the class in the java there are two methods the programmers used to handle it.
The first one is the telescoping where there are explicitly separate constructors for each and every combination of the parameters.
* Then the next one is the JavaBeans method where there are many setters in the class to set the value of the field and the deafult for the optional one.
* These two methods are ok but they are not efficient so we use the Builder pattern where we consider a seperate extra class inside the desired class and use it to build the class.
* The example is:
```
public class Main {
    public static void main(String[] args) {
      System.out.println("Hello, World!");
      Testing tes = new Testing.Builder(30,40).hai(5).build();
      System.out.println(tes.hello);
    }
}
public class Testing{
  final int hello;
  private final int hello1;
  private final int hai;
  
  public static class Builder{
    final int hello;
    private final int hello1;
    private int hai = 0;
    public Builder(int h1,int h2){
      this.hello = h1;
      this.hello1 = h2;
    }
    public Builder hai(int h){
      hai = h;
      return this;
    }
    public Testing build(){
      return new Testing(this);
    }
  }
  private Testing(Builder builder){
    hello = builder.hello;
    hello1 = builder.hello1;
    hai = builder.hai;
  }
}
```
* So this is where the things gets intresting where we can return the Builder in the parameter setting method called `hai()`. This means that in the client call the    `Testing.Builder(30,40).hai(5).build()` the `.` syntax is the chaining where each one return a object which is chained into one.
* The Builder pattern is so useful in the subclassing like when an another class want to have a builder method it can inherit a builder from an another class.
## Enforce the singleton property with a private constructor or an enum type:
* A singleton class is an class which is instantiated only once or an static propert class.
* There are two common way to implement singleton. The both uses the private constructor and the public static member to provide the access to the single instance. The first one is to use the member as a final field.
* Then the second one is the using the static factory method as a public member.
* 